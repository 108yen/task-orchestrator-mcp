# Requirements Document

## Introduction

エージェントに対してタスクを管理するためのツール群を提供するMCPサーバーです。タスクのCRUD操作および、進捗管理等の機能を提供し、AIエージェントが実行すべきタスクを階層構造で管理できるシステムを構築します。

## Requirements

### Requirement 1

**User Story:** AIエージェントとして、階層構造でタスクを作成・管理したい。複雑なワークフローを親子関係で整理できるようにするため。

#### Acceptance Criteria

1. タスクが作成されたとき、システムはタスクに一意のIDを割り当てること
2. 親タスクが指定されてタスクが作成されたとき、システムは親タスクの `tasks` 配列の指定された位置に新しいタスクを直接格納すること
3. タスクが作成されたとき、システムは名前、説明、ステータス、および空の `tasks` 配列を保存すること
4. 親タスクが提供されない場合、システムはトップレベル（ルート）のタスクを作成すること
5. ルートタスクが作成された場合、システムはそのタスクを達成するためのサブタスクの作成を推奨する内容も含めて返すこと
6. 各タスクは独自の `tasks` 配列を持ち、その中にサブタスクを格納できること
7. 深いネストレベル（任意の階層の深さ）のタスク構造をサポートすること

### Requirement 2

**User Story:** AIエージェントとして、タスクのCRUD操作を実行したい。タスクデータの完全なライフサイクルを管理できるようにするため。

#### Acceptance Criteria

1. タスク作成時、システムは名前、説明、親タスクID、配列内挿入位置パラメータを受け入れること
2. タスク作成時、システムはオプションで完了条件（`completion_criteria`）と制約（`constraints`）を受け入れること
3. タスク作成時に挿入位置が未指定の場合、システムは親の `tasks` 配列の末尾に新しいタスクを追加すること
4. タスク作成時に挿入位置が指定された場合、システムは指定された位置に新しいタスクを挿入し、後続のタスクを後方にシフトすること
5. タスク取得時、システムはIDによって完全なタスクオブジェクト（そのタスクのサブタスクも含む）を返すこと
6. タスク一覧取得時、システムは指定された親タスクIDによる階層レベルでのフィルタリングをオプションで提供すること
7. タスク更新時、システムは指定されたフィールドを変更すること
8. タスク削除時、システムはその親タスクの `tasks` 配列からタスクを削除すること。削除対象タスクにサブタスクがある場合、それらも再帰的に削除すること

### Requirement 3

**User Story:** AIエージェントとして、タスクの実行順序とステータスを管理したい。進捗を追跡し、次のアクションを決定できるようにするため。

#### Acceptance Criteria

1. タスク開始時、システムはステータスを'in_progress'に変更すること
2. タスク開始時、そのタスク自身およびすべての親タスクに設定されている完了条件（`completion_criteria`）や制約（`constraints`）を集約して返すこと
3. タスク開始時、同じ親タスクの `tasks` 配列内で開始しようとしたタスクより前に位置するタスクの中に完了ステータス（'done'）になっていないタスクがある場合、システムはその旨のメッセージとエラーを返すこと
4. タスク開始時、そのタスクの `tasks` 配列にサブタスクがある場合、最も深いネストレベルにある完了していない最初のサブタスクまでの全ての中間階層タスクのステータスを'in_progress'に変更すること
5. ネストされたタスク階層において、システムは再帰的に最も深い未完了タスクを特定し、そのタスクを自動的に開始すること
6. タスク開始時、システムは開始されたタスクとサブタスクの情報を統一されたテーブル形式のサマリーと共に返すこと。このテーブルには、すべてのタスクのデータを含み、どのタスクのステータスが変更されたかを示す列と、各タスクの親タスクを示す列を含めること
7. タスク完了時、システムはステータスを'done'に変更し、解決内容を記録すること
8. タスク完了時、システムは次に実行すべきタスクを特定すること
9. 次のタスクが存在しない場合、システムは全タスクの完了を示すこと
10. タスクの実行順序は、親タスクの `tasks` 配列内での位置によって決定されること
11. タスク完了時、システムは全体の進捗状況を統一されたマークダウンテーブル形式で表示すること。このテーブルは開始時のテーブルと同じ形式を使用し、すべてのタスクのデータを含み、どのタスクのステータスが変更されたかを示す列と、各タスクの親タスクを示す列を含めること
12. 進捗サマリーには、各親タスクの進行状況、完了済みサブタスク数、残りサブタスク数、完了率を含むこと
13. 進捗サマリーには、全体統計（総タスク数、完了済み数、進行中数、未着手数、完了率）を含むこと
14. タスク階層の構造と現在の実行状況をエージェントが把握できるよう、階層構造をテーブル形式で表示すること
15. タスク完了時、そのタスクの `tasks` 配列に未完了のサブタスクが存在する場合、システムはエラーを発生させ、そのタスクの完了操作を拒否すること
16. タスク完了時、その階層のサブタスクがすべて完了している場合、システムは親タスクのステータスを自動的に'done'に変更すること
17. システム全体で、末端ノード（サブタスクを持たないタスク、すなわち `tasks` 配列が空のタスク）のうち一つだけが'in_progress'ステータスを持つことを許可すること。親ノードは子ノードが'in_progress'の場合に限り'in_progress'ステータスになること
18. startTaskが実行された際、そのタスクの全ての親ノード（タスク階層をルートまで遡って）のステータスを'in_progress'に更新すること

### Requirement 4

**User Story:** システム管理者として、設定可能なデータ永続化を利用したい。ファイルベースのストレージとインメモリ操作を選択できるようにするため。

#### Acceptance Criteria

1. FILE_PATH環境変数が設定されている場合、システムは指定されたJSONファイルにデータを永続化すること
2. FILE_PATH環境変数が設定されていない場合、システムはメモリのみのモードで動作すること
3. ファイル永続化を使用する場合、システムは起動時に既存のタスク階層データを読み込むこと
4. ファイル永続化を使用する場合、システムは各変更後にタスク階層データをファイルに書き込むこと
5. メモリモードを使用する場合、システムはファイル操作を実行しないこと
6. データ形式は、ルートタスクの配列として格納され、各タスクは自身の `tasks` 配列にサブタスクを含むネストした構造であること

### Requirement 5

**User Story:** 開発者として、システムがMCP準拠のツールを提供することを求める。MCP互換クライアントと統合できるようにするため。

#### Acceptance Criteria

1. サーバー起動時、システムは全てのタスク管理ツールをMCPサーバーに登録すること
2. ツールが呼び出されたとき、システムはツールスキーマに従って入力パラメータを検証すること
3. ツールが正常に実行されたとき、システムは期待される出力形式を返すこと
4. エラーが発生したとき、システムは適切なエラーメッセージを返すこと
5. サーバーが実行されているとき、システムは通信にStdioServerTransportを使用すること
6. ツールのパラメータスキーマは、新しいタスク階層構造（親タスクIDによる指定、`tasks` 配列内でのネスト）に対応していること

### Requirement 6

**User Story:** AIエージェントとして、タスクとそのサブタスクを一括作成したい。複雑なプロジェクト構造やワークフローテンプレートを効率的に設定できるようにするため。

#### Acceptance Criteria

1. `createTask`ツールは、必須の`name`パラメータを使用してメインタスクを作成すること
2. `description`パラメータが指定された場合、作成されるタスクの説明として設定すること
3. `tasks`パラメータが指定された場合、作成されたメインタスクのサブタスクとして一緒に作成すること
4. サブタスクの各`tasks`プロパティに含まれるサブタスクを再帰的に作成すること
5. システムは作成されたメインタスクを指定された親タスクまたはルートレベルに配置すること
6. タスク作成が成功した場合、システムは作成されたタスク（サブタスクを含む完全な構造）を返すこと
7. 入力タスクにIDが含まれている場合はそのIDを保持し、含まれていない場合は新しい一意のIDを割り当てること
8. 作成された全てのタスクは、作成時点でステータス`todo`を持つこと
9. タスク作成中にエラーが発生した場合、システムは全ての作成操作をロールバックし、エラー発生前の状態を保持すること
